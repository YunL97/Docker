# Docker

* 도커와 쿠버네티스를 이용해서 복잡한 어플리케이션을 더쉽게 관리, 배포, 개발 가능
* 도커: 컨테이너 기술
* 컨테이너에 다양한 상품을 넣을 수 있지만 그 후에는 자체적으로 보관 격리 -> 한 컨테이너의 상품은 다른 컨테이너의 상품과 섞이지 않는다
* 도커는 컨테이너를 구축하기 위한 도구, 컨테이너의 생성, 관리 프로세스를 단순화하는 도구
* 컨테이너를 만들면 작업이 아주 간편해진다
* 특정 버전을 컨테이너에 고정해서 코드가 항상 정확한 버전으로 실행이가능하다
* 컨테이너는 운영체제가 존재하지만 하나의 머신에 몇대의 머신을 설치하지 않음 -> 그대신 운영체제가 기본적으로 내재하고 있거나 컨테이너 에뮬레이트를 지원하는 내장 컨테이너를 활용 -> 고커가 이것이 작동하도록 처리 -> 그위에 도커 엔진이라는 도구를 실행하고 우리가 설치할때 도커에 의해 모두 설정된다
* 컨테이너는 버츄얼 머신에 설치하는것보다 훨씬 작은 운영체제의 매우 가벼운 버전
* 컨테이너: 애플리케이션, 웹사이트, 노드서버 ,전체환경 등 무엇이든 포함하는 작은 패키지
* 이미지: 컨테이너의 청사진, 실제로 코드와 코드를 실행하는데 필요한 도구, 이미지는 모든 설정 명령과 모든 코드가 포함된 공유 가능한 패키지, 컨테이너는 그러한 이미지의 구체적인 실행 인스턴스
* 이미지를 기반으로 여러 컨테이너를 만들 수 있다
```
//Dockerfile에서

WORKDIR /app // 앞으로의 모든 명령이 app 폴더에서 실행되게하는 설정

COPY . /app // 처음 .은 외부, /app은 도커 컨테이너 내부 app 폴더에 복사가 된다는 뜻, app폴더가 존재하지 않는 경우에는 이미지와 컨테이너에 생성된다
```
* build를 통해 도커 이미지를 만들 수 있음
* RUN npm install 전에 COPY package.json을 해줘서 package.json이 변경되지 않으면 npm install을 안해줘도 되기 때문에 npm install의 캐시된 결과를 사용할 수 있기 때문에 속도가 빠르다
* 도커로 할수있는 중요한 한가지는 중지된 컨테이너를 다시 시작가능
* attached(개발용), detached(프로덕트배포용)
* attached모드: 컨테이너의 출력 결과를 터미널로 수신, docker run, log 보려면 attached모드
* detached모드: 수신x, docker start, start -a 플래그를 추가하면 attached모드로 바로 시작 가능
* 컨테이너와 터미널로 상호작용을 해야하는경우 -i -t 플래그를 이용하여 상호작용 가능하다 줄여서 -it
* 레이어: 이미지와 컨테이너의 핵심적인 부분, 레이어 시스템 덕분에 도커는 빠르고 효율적인 이미지 관리와 컨테이너 생성을 제공
  * 이미지 레이어: 도커 이미지는 여러 레이어로 구성, 하나의 레이어는 운영체제, 다른 레이어는 소프트웨어, 라이브러리를 포함가능, 이레이어 들이 순차적으로 쌓여서 완전한 이미지를 형성
  * 효율성:레이어 방식은 저장공간을 효율적으로 사용, 동일한 레이어를 공유하는 여러 이미지는 동일한 레이어를 다시 다운로드하거나 저장할 필요가 없음
  * 컨테이너레이어: 컨테이너가 실행될때 도커는 읽기전용의 이미지 레이어 위에 쓰기 가능한 레이어를 추가, 이 레이어는 컨테이너의 생명주기 동안 발생하는 모든 변경사항을 저장

* 팀 구성원과 공유하거나 나중에 배포를 위해 공유하는 경우 일반적으로 로우 도커파일이 아닌 완성된 이미지로 작업한다
* 도커허브: 깃허브같은거
* 도커허브를이용해서 docker push, docker pull 을해서 다른사람들과 공유 가능하다
* push 할때는 로그인이 필요한데 pull 할때는 필요없음

# 데이터 관리 및 볼륨으로 작업
* 도커의 핵심: 동일한 이미지에 기바한 다수의 컨테이너가 서로에게 완전히 격리된다는것
* 볼륨: 데이터를 유지하도록 도운다, 볼륨은 호스트 머신의 폴더, 즉 호스트 컴퓨터에 장착된 하드 드라이브에 존재해서 사용가능하거나 컨테이너로 매핑되는것 -> 볼륨은 도커가 인식하는 호스트 머신인 컴퓨터에 있는폴더로서 도커 컨테이너 내부의 폴더에 매핑 -> 지속적인 관계나 연결이 없으며 이미지에 복사되는 일회성 스냅샷일 뿐이다
  * 익명볼륨은 하나의 컨테이너에만 쓸모가 있다. 근데 --rm 옵션 없이 컨테이너를 제거하면 익명 볼륨은 사라지지 않고 새로운 컨테이너를 만들면 익명 볼륨이 새로 생성되서 이게 계속 쌓인다 -> docker volume prune
  * 컨테이너와 독립적으로 존재
* 바인드마운트: 변경사항이 있을때마다 매번 전체 이미지를 리빌드하고 컨테이너를 다시 시작해야하는데 이것을 바인드 마운트가 도와준다
  * 볼륨과 달리 바인드 마운트는 위치를 알고 있다.
  * 소스코드 같은 영구적이고 자주 변경되는 데이터에 주로 사용
  * 소스코드를 바인드 마운트에 넣으면 컨테이너가 이를 인식해서 소스코드를 실제로 스냅샷에 복사하는것이아닌 바인딩 마운트에서 복사 -> 컨테이너는 항상 최신 코드에 엑세스 할 수 있다
  * 바인드 마운트는 영구적이고 편집 가능한 데이터에 적합하다
  * 바인드마운트는 컨테이너 내부에서 설정해야한다
  * 콜론앞에 로컬머신 경로가 붙으면 바인드마운트가 되고 콜론 앞에 경로가 아닌것이 붙으면 볼륨이름으로 취급되어 명명된 볼륨이 된다
* 도커는 로컬 호스트 폴더를 건드리지 않는다. 실수로 컴퓨터에서 많은 중요한것들을 삭제할 수 있기 때문

```
docker run -v /app/data... // 익명의 볼륨을 생성
docker run -v data:/app/data... // 명명된 볼륨을 생성
docker run -v /path/to/code:/app/code... // 실제로 호스트 머신의 폴더를 가리키는 절대경로 -> 바인드 마운트
```
* 익명볼륨: 컨테이너에 연결된 일종의 볼륨,
  * 컨테이너가 제거되면 볼륨 역시 제거 
  * 컨테이너간에 데이터 공유x, 
  * 컨테이너에 이미 존재하는 특정 데이터를 잠그는데 유용, 
  * 시간절약가능
  * 호스트머신에 폴더를 생성

* 명명된볼륨: 
  * 도커파일에서 생성할수 없다
  * 특정 컨테이너에 연결되어 있지 않기 때문에 컨테이너를 종료하고 제거해도 살아있다
  * 컨테이너간 데이터공유가능
  * 명명된 볼륨이 존재하면 볼륨을 생성하는 대신 기존것을 사용
* 바인드마운트
  * 하나의 특정 컨테이너에 국한되지 않으며 다수의 컨테이너에 연결가능
  * 컨테이너 종료, 제거후에도 유지

* .dockerignore를 통해서 copy 명령으로 복하하면 안되는 폴더와 파일 지정가능 ex) node_module
* 도커파일에서 ENV PORT 80 을 통해 동적 설정 가능 아니면 터미널에 --env PORT=80 설정
* 도커 파일에 평문으로 민감한 정보를 포함시키고 이를 이미지에 추가하면 docker historu를 통해 정보 노출 가능 -> 환경변수 사용, Secrets 사용, dockerignore 파일 사용 등등

# 교차 컨테이너 통신

* 컨네이너 내부에서 네트워크를 이용가능
* 컨테이너 끼리는 다수의 커테이너가 연결가능하고 서로 통신이 가능하다.
* 엔드포인트: 요청을 받아 응답을 제공하는 서비스를 사용할 수 있는 지점
* 기본적으로 컨테이너는 월드와이드 웹에 요청을 보낼 수 있다.
* 로컬에 있는 db를 사용해야할때는 localhost:2133 대신 host.docker.internal:2133 을 사용 -> 컨테이너와 호스트 머신간의 통신을 보장
* docker명령에 --network 옵션을 추가하면 모든 컨테이너를 하나의 동일한 네트워크를 밀어넣을 수 있다 -> 즉 모든 컨테이너가 서로 통신할 수 있는 네트워크가 생성된다  
* 같은 네트워크를 사용하는경우 host.docker.internal 이나 컨테이너 ip가 아닌  mongodb:27017로 컨테이너 이름을 사용하면 된다
* 컨테이너 실행할때 -p 를사용안해도 되는데 -p옵션은 로컬호스트 머신이나 컨테이너 네트워크 외부에서 그 컨테이너의 무언가에 연결할 계획인 경우에만 필요하기 때문  
* 컨테이너에서 요청을 전송할때만 자동 ip 변환이 발생한다. 요청이 컨테이너에서 전송되지 않거나 요청이 다른곳, ex 브라우저에서 생성된 경우 즉 사용자가 웹 앱을 방문하여 js 코드가 브라우저에서 실행중이고 그 브라우저에서 요청이 전송되면 도커는 아무 작업도 수행하지 않는다.

# 다중 컨테이너 구축

* 도커에서 리액트 개발을 할때는 node 베이스로 해야한다. node가 리액트 코드를 최적화 하고 또한 브라우저가 이해할 수 있는 코드로 변환하는데 사용되기때문
* react의 경우 docker run 명령어에 -it(인터렉티브모드) 를 적용해야한다 안붙이면 서버가 유지되는게 아니고 명령어를 시작해준 당시만 돌아갔다가 바로중단된다
* 백엔드의 경우 node app.js 를 통해서 노드 런타임에 의해 컨테이너에서 직접 실행되지만  백엔드의 react의 경우 npm start 만을 실행 -> 브라우저에서 실행 -> --network를 하는경우 api 통신을 컨테이너 이름으로 하는데 브라우저에서는 컨테이너 이름을 모르기 때문에 오류가난다 -> localhost 로 변경, 로컬호스트는 브라우저가 이해하는 식별자
* 
